<!doctype html>
<html lang="en">
    {% load static %}
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="csrf-token" content="{{ csrf_token }}" />
        <title>Hierarchical RL Simulation</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: "Inter", sans-serif;
            }
            canvas {
                background-color: #2b2b2b;
                border: 2px solid #1a1a1a;
                border-radius: 0.5rem;
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
                width: 100%;
                height: auto;
            }
            .ui-box {
                background: #4a5462;
                color: #e0e0e0;
                padding: 1rem;
                border-radius: 0.5rem;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                border: 1px solid #5a6472;
            }
            .control-group {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
                background: #3d4551;
                padding: 0.75rem;
                border-radius: 0.5rem;
            }
            .control-group label {
                font-size: 0.875rem;
                font-weight: bold;
            }
            .control-group input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                width: 100%;
                height: 8px;
                background: #2b2b2b;
                border-radius: 4px;
                outline: none;
            }
            .control-group input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                background: #6db46f;
                cursor: pointer;
                border-radius: 50%;
            }
            .control-group input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                background: #6db46f;
                cursor: pointer;
                border-radius: 50%;
            }
            .vis-toggle-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            .toggle-label {
                display: flex;
                align-items: center;
                cursor: pointer;
                padding: 0.5rem;
                background-color: #3d4551;
                border-radius: 0.375rem;
                transition: background-color 0.2s;
            }
            .toggle-label:hover {
                background-color: #5a6472;
            }
            .toggle-label input {
                display: none;
            }
            .toggle-color-box {
                width: 1rem;
                height: 1rem;
                border-radius: 0.25rem;
                margin-right: 0.75rem;
                border: 2px solid transparent;
                transition: border-color 0.2s;
            }
            .toggle-label input:checked + .toggle-color-box {
                border-color: #fff;
            }
        </style>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
            rel="stylesheet"
        />
    </head>
    <body class="bg-slate-800 text-slate-200">
        <div class="w-full min-h-screen flex flex-col items-center p-4">
            <div class="w-full max-w-7xl mb-6 text-center">
                <h1 class="text-4xl font-bold text-white mb-2">
                    Nigel's Quest: A Hierarchical Learning Adventure
                </h1>
                <p class="text-slate-400 max-w-3xl mx-auto">
                    This is an interactive Hierarchical Q-Learning simulation. A
                    high-level "Manager" agent learns the overall strategy by
                    giving commands to a low-level "Worker" agent, which learns
                    how to execute those commands efficiently using Hindsight
                    Experience Replay.
                </p>
            </div>

            <h2
                id="status"
                class="text-xl font-bold text-center mb-4 text-white"
            >
                Status: Loading assets...
            </h2>

            <div
                class="w-full max-w-7xl flex-grow flex flex-col lg:flex-row gap-6"
            >
                <div
                    class="canvas-container flex flex-col gap-4 w-full lg:w-2/3"
                >
                    <canvas id="simulationCanvas"></canvas>
                    <canvas id="qValueCanvas"></canvas>
                </div>

                <div
                    id="ui-panel"
                    class="w-full lg:w-1/3 flex-shrink-0 flex flex-col gap-4"
                >
                    <div id="score-board" class="ui-box">
                        <h3 class="font-bold mb-2">Scoreboard</h3>
                        <p class="flex justify-between">
                            <span>Manager Steps:</span
                            ><strong id="episodesCompleted">0</strong>
                        </p>
                    </div>
                    <div id="milestones-board" class="ui-box">
                        <h3 class="font-bold mb-2">Milestones</h3>
                        <p class="flex justify-between">
                            <span>Log Picked Up:</span
                            ><strong id="ms-picked-up">0</strong>
                        </p>
                        <p class="flex justify-between">
                            <span>Bridge Placed:</span
                            ><strong id="ms-placed">0</strong>
                        </p>
                        <p class="flex justify-between">
                            <span>Bridge Crossed:</span
                            ><strong id="ms-crossed">0</strong>
                        </p>
                        <p class="flex justify-between">
                            <span>Reached Home:</span
                            ><strong id="ms-home">0</strong>
                        </p>
                    </div>
                    <div id="vis-control-board" class="ui-box">
                        <h3 class="font-bold mb-2">Worker Brain View</h3>
                        <div id="viewStateToggles" class="vis-toggle-grid">
                            <label class="toggle-label">
                                <input
                                    type="radio"
                                    name="vis-toggle"
                                    value="no_bridge"
                                    checked
                                />
                                <span
                                    class="toggle-color-box"
                                    style="background-color: #6ee7b7"
                                ></span>
                                Goal: Log
                            </label>
                            <label class="toggle-label">
                                <input
                                    type="radio"
                                    name="vis-toggle"
                                    value="has_bridge"
                                />
                                <span
                                    class="toggle-color-box"
                                    style="background-color: #60a5fa"
                                ></span>
                                Goal: River
                            </label>
                            <label class="toggle-label">
                                <input
                                    type="radio"
                                    name="vis-toggle"
                                    value="bridge_placed"
                                />
                                <span
                                    class="toggle-color-box"
                                    style="background-color: #facc15"
                                ></span>
                                Goal: House
                            </label>
                        </div>
                    </div>
                    <div id="controls" class="grid grid-cols-1 gap-4">
                        <div class="control-group">
                            <label for="agentsSlider"
                                >Agents (<span id="agentsValue">10</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="agentsSlider"
                                min="1"
                                max="10"
                                step="1"
                                value="10"
                            />
                        </div>
                        <div class="control-group">
                            <label for="dfSlider"
                                >Discount Factor (<span id="dfValue">0.9</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="dfSlider"
                                min="0.1"
                                max="0.99"
                                step="0.01"
                                value="0.9"
                            />
                        </div>
                        <div class="control-group">
                            <label for="lrSlider"
                                >Learning Rate (<span id="lrValue">0.6</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="lrSlider"
                                min="0.01"
                                max="1"
                                step="0.01"
                                value="0.6"
                            />
                        </div>
                        <div class="control-group">
                            <label for="erSlider"
                                >Exploration Rate (<span id="erValue">0.7</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="erSlider"
                                min="0"
                                max="1"
                                step="0.01"
                                value="0.7"
                            />
                        </div>
                        <div class="control-group">
                            <label for="batchSlider"
                                >Replay Batch Size (<span id="batchValue"
                                    >32</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="batchSlider"
                                min="4"
                                max="128"
                                step="4"
                                value="32"
                            />
                        </div>
                        <div class="control-group">
                            <label for="costSlider"
                                >Step Penalty (<span id="costValue">14</span
                                >)</label
                            >
                            <input
                                type="range"
                                id="costSlider"
                                min="1"
                                max="25"
                                step="1"
                                value="14"
                            />
                        </div>
                        <div class="control-group">
                            <label for="speedSlider"
                                >Sim Speed (<span id="speedValue">50</span
                                >ms)</label
                            >
                            <input
                                type="range"
                                id="speedSlider"
                                min="0"
                                max="200"
                                step="10"
                                value="50"
                            />
                        </div>
                    </div>
                    <button
                        id="resetButton"
                        class="w-full py-3 px-6 text-base font-bold text-white bg-green-600 rounded-lg hover:bg-green-700 transition-colors"
                    >
                        Start / Reset Simulation
                    </button>
                </div>
            </div>
        </div>

        <script>
            // --- DOM ELEMENT REFERENCES ---
            const simCanvas = document.getElementById("simulationCanvas"),
                simCtx = simCanvas.getContext("2d");
            const qCanvas = document.getElementById("qValueCanvas"),
                qCtx = qCanvas.getContext("2d");
            const csrfToken = document
                .querySelector('meta[name="csrf-token"]')
                .getAttribute("content");
            const statusEl = document.getElementById("status");
            const resetButton = document.getElementById("resetButton");
            const agentsSlider = document.getElementById("agentsSlider"),
                lrSlider = document.getElementById("lrSlider"),
                dfSlider = document.getElementById("dfSlider"),
                erSlider = document.getElementById("erSlider"),
                speedSlider = document.getElementById("speedSlider"),
                batchSlider = document.getElementById("batchSlider"),
                costSlider = document.getElementById("costSlider");
            const agentsValue = document.getElementById("agentsValue"),
                lrValue = document.getElementById("lrValue"),
                dfValue = document.getElementById("dfValue"),
                erValue = document.getElementById("erValue"),
                speedValue = document.getElementById("speedValue"),
                batchValue = document.getElementById("batchValue"),
                costValue = document.getElementById("costValue");
            const episodesCompletedEl =
                document.getElementById("episodesCompleted");
            const milestoneElements = {
                picked_up: document.getElementById("ms-picked-up"),
                placed: document.getElementById("ms-placed"),
                crossed: document.getElementById("ms-crossed"),
                home: document.getElementById("ms-home"),
            };
            const viewStateToggles =
                document.getElementById("viewStateToggles");

            // --- GLOBAL STATE ---
            let gameState = null,
                renderLoopRunning = false,
                simWorker = null,
                qValueData = null,
                qValueUpdateInterval = null;
            let GRID_COLS = 20,
                GRID_ROWS = 12,
                TILE_DEST_SIZE = 40;
            const charSheet = new Image(),
                tileSheet = new Image();
            let loadedAssets = 0;
            const totalAssets = 2;

            function assetLoaded() {
                if (++loadedAssets === totalAssets) startOrResetSimulation();
            }
            charSheet.onload = tileSheet.onload = assetLoaded;
            charSheet.onerror = tileSheet.onerror = () => {
                console.error("Asset failed to load.");
                statusEl.textContent =
                    "Error: Could not load simulation assets.";
            };
            charSheet.src = "{% static 'images/character.png' %}";
            tileSheet.src = "{% static 'images/Overworld.png' %}";

            // --- SPRITE & COLOR MAPPING ---
            const TILE_SOURCE_SIZE = 16;
            const TILE_MAP = {
                dirt: { x: 1, y: 4 },
                grass: { x: 0, y: 0 },
                grass_border_t: { x: 1, y: 3 },
                grass_border_l: { x: 0, y: 4 },
                grass_border_r: { x: 2, y: 4 },
                grass_border_b: { x: 1, y: 5 },
                grass_corner_tl: { x: 0, y: 3 },
                grass_corner_tr: { x: 2, y: 3 },
                grass_corner_bl: { x: 0, y: 5 },
                grass_corner_br: { x: 2, y: 5 },
                water_grass_l: { x: 2, y: 7 },
                water_grass_r: { x: 4, y: 7 },
                water: { x: 3, y: 7 },
                water_ripple: [
                    { x: 3, y: 1 },
                    { x: 2, y: 1 },
                    { x: 1, y: 1 },
                    { x: 0, y: 1 },
                ],
                bridge_asset: [
                    { x: 3, y: 5 },
                    { x: 4, y: 5 },
                    { x: 5, y: 5 },
                ],
                house: [
                    [
                        { x: 13, y: 5 },
                        { x: 14, y: 5 },
                    ],
                    [
                        { x: 13, y: 6 },
                        { x: 14, y: 6 },
                    ],
                    [
                        { x: 13, y: 7 },
                        { x: 14, y: 7 },
                    ],
                ],
            };
            const CHAR_SPRITE_MAP = {
                DOWN: [
                    { top: { x: 0, y: 0 }, bottom: { x: 0, y: 1 } },
                    { top: { x: 1, y: 0 }, bottom: { x: 1, y: 1 } },
                    { top: { x: 2, y: 0 }, bottom: { x: 2, y: 1 } },
                    { top: { x: 3, y: 0 }, bottom: { x: 3, y: 1 } },
                ],
                LEFT: [
                    { top: { x: 0, y: 6 }, bottom: { x: 0, y: 7 } },
                    { top: { x: 1, y: 6 }, bottom: { x: 1, y: 7 } },
                    { top: { x: 2, y: 6 }, bottom: { x: 2, y: 7 } },
                    { top: { x: 3, y: 6 }, bottom: { x: 3, y: 7 } },
                ],
                RIGHT: [
                    { top: { x: 0, y: 2 }, bottom: { x: 0, y: 3 } },
                    { top: { x: 1, y: 2 }, bottom: { x: 1, y: 3 } },
                    { top: { x: 2, y: 2 }, bottom: { x: 2, y: 3 } },
                    { top: { x: 3, y: 2 }, bottom: { x: 3, y: 3 } },
                ],
                UP: [
                    { top: { x: 0, y: 4 }, bottom: { x: 0, y: 5 } },
                    { top: { x: 1, y: 4 }, bottom: { x: 1, y: 5 } },
                    { top: { x: 2, y: 4 }, bottom: { x: 2, y: 5 } },
                    { top: { x: 3, y: 4 }, bottom: { x: 3, y: 5 } },
                ],
            };
            let activeRipples = [];
            const STATE_COLORS = {
                no_bridge: "99, 230, 157",
                has_bridge: "96, 165, 250",
                bridge_placed: "250, 204, 21",
                crossed_bridge: "244, 114, 182",
                negative: "239, 68, 68",
            };

            // --- DRAWING FUNCTIONS ---
            function drawScene() {
                if (gameState) {
                    simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
                    drawWorld();
                    drawAgents();
                }
            }
            function drawWorld() {
                if (
                    !gameState ||
                    !gameState.worlds ||
                    !tileSheet.complete ||
                    tileSheet.naturalHeight === 0
                )
                    return;
                if (!simCanvas.background) {
                    const bgCanvas = document.createElement("canvas");
                    bgCanvas.width = simCanvas.width;
                    bgCanvas.height = simCanvas.height;
                    const bgCtx = bgCanvas.getContext("2d");
                    for (let r = 0; r < GRID_ROWS; r++) {
                        for (let c = 0; c < GRID_COLS; c++) {
                            let tile = TILE_MAP.dirt;
                            if (r === 0)
                                tile =
                                    c === 0
                                        ? TILE_MAP.grass_corner_tl
                                        : c === GRID_COLS - 1
                                          ? TILE_MAP.grass_corner_tr
                                          : TILE_MAP.grass_border_t;
                            else if (r === GRID_ROWS - 1)
                                tile =
                                    c === 0
                                        ? TILE_MAP.grass_corner_bl
                                        : c === GRID_COLS - 1
                                          ? TILE_MAP.grass_corner_br
                                          : TILE_MAP.grass_border_b;
                            else if (c === 0) tile = TILE_MAP.grass_border_l;
                            else if (c === GRID_COLS - 1)
                                tile = TILE_MAP.grass_border_r;
                            bgCtx.drawImage(
                                tileSheet,
                                tile.x * TILE_SOURCE_SIZE,
                                tile.y * TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                c * TILE_DEST_SIZE,
                                r * TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                            );
                        }
                    }
                    simCanvas.background = bgCanvas;
                }
                simCtx.drawImage(simCanvas.background, 0, 0);
                const firstWorld = gameState.worlds[0];
                if (!firstWorld) return;
                const riverStartCol = firstWorld.river_start_col,
                    riverWaterWidth = 3;
                for (let r = 0; r < GRID_ROWS; r++) {
                    simCtx.drawImage(
                        tileSheet,
                        TILE_MAP.water_grass_l.x * TILE_SOURCE_SIZE,
                        TILE_MAP.water_grass_l.y * TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        riverStartCol * TILE_DEST_SIZE,
                        r * TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                    );
                    for (let c = 1; c <= riverWaterWidth; c++) {
                        simCtx.drawImage(
                            tileSheet,
                            TILE_MAP.water.x * TILE_SOURCE_SIZE,
                            TILE_MAP.water.y * TILE_SOURCE_SIZE,
                            TILE_SOURCE_SIZE,
                            TILE_SOURCE_SIZE,
                            (riverStartCol + c) * TILE_DEST_SIZE,
                            r * TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                        );
                    }
                    simCtx.drawImage(
                        tileSheet,
                        TILE_MAP.water_grass_r.x * TILE_SOURCE_SIZE,
                        TILE_MAP.water_grass_r.y * TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        (riverStartCol + riverWaterWidth + 1) * TILE_DEST_SIZE,
                        r * TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                    );
                }
                if (Math.random() < 0.05)
                    activeRipples.push({
                        x:
                            riverStartCol +
                            1 +
                            Math.floor(Math.random() * riverWaterWidth),
                        y: Math.floor(Math.random() * GRID_ROWS),
                        frame: 0,
                        life: 0,
                    });
                activeRipples.forEach((ripple, index) => {
                    const tile = TILE_MAP.water_ripple[ripple.frame];
                    simCtx.drawImage(
                        tileSheet,
                        tile.x * TILE_SOURCE_SIZE,
                        tile.y * TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        ripple.x * TILE_DEST_SIZE,
                        ripple.y * TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                    );
                    ripple.life++;
                    if (ripple.life % 8 === 0) ripple.frame++;
                    if (ripple.frame >= TILE_MAP.water_ripple.length)
                        activeRipples.splice(index, 1);
                });
                for (let r = 0; r < TILE_MAP.house.length; r++) {
                    for (let c = 0; c < TILE_MAP.house[r].length; c++) {
                        const tile = TILE_MAP.house[r][c];
                        simCtx.drawImage(
                            tileSheet,
                            tile.x * TILE_SOURCE_SIZE,
                            tile.y * TILE_SOURCE_SIZE,
                            TILE_SOURCE_SIZE,
                            TILE_SOURCE_SIZE,
                            (firstWorld.house_start_col + c) * TILE_DEST_SIZE,
                            (firstWorld.house_start_row + r) * TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                        );
                    }
                }
                gameState.worlds.forEach((world) => {
                    if (world.bridge_piece) {
                        for (let i = 0; i < TILE_MAP.bridge_asset.length; i++) {
                            const tile = TILE_MAP.bridge_asset[i];
                            simCtx.drawImage(
                                tileSheet,
                                tile.x * TILE_SOURCE_SIZE,
                                tile.y * TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                (world.bridge_piece.ax + i) * TILE_DEST_SIZE,
                                world.bridge_piece.ay * TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                            );
                        }
                    }
                    if (world.placed_bridge) {
                        for (let i = 0; i < TILE_MAP.bridge_asset.length; i++) {
                            const tile = TILE_MAP.bridge_asset[i];
                            simCtx.drawImage(
                                tileSheet,
                                tile.x * TILE_SOURCE_SIZE,
                                tile.y * TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                TILE_SOURCE_SIZE,
                                (world.placed_bridge.ax + i) * TILE_DEST_SIZE,
                                world.placed_bridge.ay * TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                                TILE_DEST_SIZE,
                            );
                        }
                    }
                });
            }
            function drawAgents() {
                if (
                    !gameState ||
                    !gameState.worlds ||
                    !charSheet.complete ||
                    charSheet.naturalHeight === 0
                )
                    return;
                gameState.worlds.forEach((world) => {
                    const agent = world.agent;
                    const anim_frames = CHAR_SPRITE_MAP[agent.last_action];
                    if (!anim_frames) return;
                    const current_frame_index =
                        Math.floor(agent.animation_frame / 4) %
                        anim_frames.length;
                    const frame = anim_frames[current_frame_index];
                    simCtx.drawImage(
                        charSheet,
                        frame.bottom.x * TILE_SOURCE_SIZE,
                        frame.bottom.y * TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        agent.ax * TILE_DEST_SIZE,
                        agent.ay * TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                    );
                    simCtx.drawImage(
                        charSheet,
                        frame.top.x * TILE_SOURCE_SIZE,
                        frame.top.y * TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        TILE_SOURCE_SIZE,
                        agent.ax * TILE_DEST_SIZE,
                        (agent.ay - 1) * TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                        TILE_DEST_SIZE,
                    );
                });
            }
            function drawQValueVisualization() {
                if (!qValueData || !qValueData.q_maps) return;
                const { q_maps, rows, cols } = qValueData;
                const activeState = document.querySelector(
                    'input[name="vis-toggle"]:checked',
                )?.value;
                if (!activeState) {
                    qCtx.clearRect(0, 0, qCanvas.width, qCanvas.height);
                    return;
                }
                const currentMapData = q_maps[activeState];
                if (!currentMapData) return;
                const allQs = Object.values(q_maps).flatMap((mapData) =>
                    mapData.q_map.flat(),
                );
                const maxQ = Math.max(
                    ...allQs.filter((q) => q > -1000 && q < 1000),
                    0,
                );
                const minQ = Math.min(
                    ...allQs.filter((q) => q > -1000 && q < 1000),
                    0,
                );
                qCtx.clearRect(0, 0, qCanvas.width, qCanvas.height);
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const q = currentMapData.q_map[r][c];
                        let color;
                        if (q > 0) {
                            const normQ = maxQ > 0 ? q / maxQ : 0;
                            color = `rgba(${STATE_COLORS[activeState]}, ${normQ * 0.8})`;
                        } else if (q < 0) {
                            const normQ = minQ < 0 ? q / minQ : 0;
                            color = `rgba(${STATE_COLORS.negative}, ${normQ * 0.7})`;
                        } else {
                            continue;
                        }
                        qCtx.fillStyle = color;
                        qCtx.fillRect(
                            c * TILE_DEST_SIZE,
                            r * TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                            TILE_DEST_SIZE,
                        );
                    }
                }
            }

            // --- UI UPDATE FUNCTIONS ---
            function updateScoreboard() {
                if (!gameState) return;
                episodesCompletedEl.textContent = gameState.episodes_completed;
            }
            function updateMilestones() {
                if (!gameState) return;
                for (const key in milestoneElements) {
                    if (
                        gameState.milestones &&
                        gameState.milestones[key] !== undefined
                    )
                        milestoneElements[key].textContent =
                            gameState.milestones[key];
                }
            }

            // --- MAIN LOGIC ---
            function renderLoop() {
                if (!renderLoopRunning) return;
                if (gameState) {
                    drawScene();
                    drawQValueVisualization();
                    updateScoreboard();
                    updateMilestones();
                }
                requestAnimationFrame(renderLoop);
            }
            function handleResize() {
                const container = document.querySelector(".canvas-container");
                if (!container || container.clientWidth === 0) return;
                TILE_DEST_SIZE = Math.floor(container.clientWidth / GRID_COLS);
                const newWidth = TILE_DEST_SIZE * GRID_COLS,
                    newHeight = TILE_DEST_SIZE * GRID_ROWS;
                simCanvas.width = qCanvas.width = newWidth;
                simCanvas.height = qCanvas.height = newHeight;
                simCanvas.background = null;
            }

            async function startOrResetSimulation() {
                handleResize();
                statusEl.textContent = "Status: Resetting...";
                if (simWorker) simWorker.postMessage({ command: "stop" });
                if (qValueUpdateInterval) clearInterval(qValueUpdateInterval);
                renderLoopRunning = false;
                const response = await fetch("{% url 'api_state' %}", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": csrfToken,
                    },
                    body: JSON.stringify({
                        command: "reset",
                        numAgents: agentsSlider.value,
                        learningRate: lrSlider.value,
                        discountFactor: dfSlider.value,
                        explorationRate: erSlider.value,
                        batchSize: batchSlider.value,
                        costOfLiving: costSlider.value,
                    }),
                });
                if (response.ok) {
                    gameState = await response.json();
                    statusEl.textContent = `Status: ${gameState.worlds.length} agent(s) learning...`;
                    if (!renderLoopRunning) {
                        renderLoopRunning = true;
                        renderLoop();
                    }
                    simWorker = new Worker(
                        "{% static 'js/simulation_worker.js' %}",
                    );
                    simWorker.onmessage = function (e) {
                        const {
                            type,
                            gameState: newGameState,
                            qValueData: newQValueData,
                            message,
                        } = e.data;
                        if (type === "update") gameState = newGameState;
                        else if (type === "q_values_update")
                            qValueData = newQValueData;
                        else if (type === "error") {
                            statusEl.textContent = `Error: ${message}`;
                            renderLoopRunning = false;
                            if (qValueUpdateInterval)
                                clearInterval(qValueUpdateInterval);
                        }
                    };
                    simWorker.postMessage({
                        command: "start",
                        data: {
                            apiStateUrl: "{% url 'api_state' %}",
                            speed: parseInt(speedSlider.value) || 50,
                        },
                    });
                    qValueUpdateInterval = setInterval(() => {
                        if (simWorker)
                            simWorker.postMessage({
                                command: "get_q_values",
                                data: {
                                    qValueApiUrl: "{% url 'api_q_values' %}",
                                    csrfToken: csrfToken,
                                },
                            });
                    }, 100);
                } else {
                    statusEl.textContent = "Error resetting simulation.";
                }
            }

            // --- EVENT LISTENERS ---
            resetButton.addEventListener("click", startOrResetSimulation);
            window.addEventListener("resize", handleResize);
            speedSlider.addEventListener("input", (e) => {
                speedValue.textContent = `${e.target.value}`;
                if (simWorker)
                    simWorker.postMessage({
                        command: "update_speed",
                        data: { speed: parseInt(e.target.value) || 50 },
                    });
            });
            agentsSlider.addEventListener(
                "input",
                (e) => (agentsValue.textContent = e.target.value),
            );
            lrSlider.addEventListener(
                "input",
                (e) => (lrValue.textContent = e.target.value),
            );
            dfSlider.addEventListener(
                "input",
                (e) => (dfValue.textContent = e.target.value),
            );
            erSlider.addEventListener(
                "input",
                (e) => (erValue.textContent = e.target.value),
            );
            batchSlider.addEventListener(
                "input",
                (e) => (batchValue.textContent = e.target.value),
            );
            costSlider.addEventListener(
                "input",
                (e) => (costValue.textContent = e.target.value),
            );
        </script>
    </body>
</html>
